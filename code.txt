
#define min_level 6
#define max_level 8
#define critical_detail 2.0

auto detail_from_gradients = [](std::vector<v3f_t>& gradients) {

	float meanX = 0.0;
	float meanY = 0.0;
	float meanZ = 0.0;

	for (int ip = 0; ip < gradients.size(); ip++) {
		meanX += gradients[ip].x;
		meanY += gradients[ip].y; 
		meanZ += gradients[ip].z;
	}
	
	meanX /= gradients.size();
	meanY /= gradients.size();
	meanZ /= gradients.size();

	float varX = 0.0, varY = 0.0, varZ = 0.0;

	for (int ip = 0; ip < gradients.size(); ip++) {
		varX += (gradients[ip].x - meanX) * (gradients[ip].x - meanX);
		varY += (gradients[ip].y - meanY) * (gradients[ip].y - meanY);
		varZ += (gradients[ip].z - meanZ) * (gradients[ip].z - meanZ);
	}

	return varX + varY + varZ;
};



auto wsum = [](Vector3f af, Vector3f bf,float A, float B) {
	A = fabs(A - ISOLEVEL);
	B = fabs(B - ISOLEVEL);
	float D = (A + B);
	//if (fabs(D) < MCUBES_EPS) {
		return v3f_scale(v3f_add(af,bf),0.5); //default to the midpoint
	//}
	//return v3f_add(v3f_scale(af,A/D),v3f_scale(bf,B/D));
};
        
		
            
		std::deque<box_t> sectors;
		int maxcubes = 0;
		sectors.push_back(bx);
		int currentlevel = 0;

		std::vector<Triangle3f> triangles;
		std::vector<Triangle3f> patchTriangles;
		
		size_t spointer = 0; 

		while (spointer<sectors.size()) {
			box_t* sector_p = &sectors[spointer];
			box_t sector = sectors.at(spointer++);





			std::vector<float> s = global_evaluator->eval_sdf_at_points(std::vector<v3f_t>{sector.center});
			if (fabs(s[0]) > magnitude(v3f_scale(sector.diameters,0.5))) continue;



				int split = 1;
				if (sector.level > min_level) {
					if (sector.level == max_level) {
						split = 0;
					}
					else {

						std::vector<v3f_t> epoints = sector.octant_points(1.0);
						std::vector<v3f_t> epoints2 = sector.octant_points(0.5);
						epoints.insert(epoints.end(), epoints2.begin(), epoints2.end());
						std::vector<v3f_t> gradients = global_evaluator->eval_normal_at_points(epoints);
						float detail = detail_from_gradients(gradients);

						if (detail < critical_detail)
							split = 0;

					}
				}
				else {
				
					split = 1;
				}



				if (split) {
					std::vector<v3f_t> half_corners = sector.octant_points(0.5);

					sector_p->split = 1;

					box_t bx0 = box(half_corners[0], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx1 = box(half_corners[1], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx2 = box(half_corners[2], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx3 = box(half_corners[3], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx4 = box(half_corners[4], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx5 = box(half_corners[5], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx6 = box(half_corners[6], v3f_scale(sector.diameters, 0.5), sector.level + 1);
					box_t bx7 = box(half_corners[7], v3f_scale(sector.diameters, 0.5), sector.level + 1);


					sectors.push_back(bx0);
					sectors.push_back(bx1);
					sectors.push_back(bx2);
					sectors.push_back(bx3);
					sectors.push_back(bx4);
					sectors.push_back(bx5);
					sectors.push_back(bx6);
					sectors.push_back(bx7);

#define addr_bx(i) (&sectors[sectors.size()-8+i])

					addr_bx(0)->prnt = sector_p;
					addr_bx(1)->prnt = sector_p;
					addr_bx(2)->prnt = sector_p;
					addr_bx(3)->prnt = sector_p;
					addr_bx(4)->prnt = sector_p;
					addr_bx(5)->prnt = sector_p;
					addr_bx(6)->prnt = sector_p;
					addr_bx(7)->prnt = sector_p;

					addr_bx(0)->east = addr_bx(1);
					addr_bx(0)->south = addr_bx(3);
					addr_bx(0)->above = addr_bx(4);

					addr_bx(1)->west = addr_bx(0);
					addr_bx(1)->south = addr_bx(2);
					addr_bx(1)->above = addr_bx(5);

					addr_bx(2)->west = addr_bx(3);
					addr_bx(2)->north = addr_bx(1);
					addr_bx(2)->above = addr_bx(6);


					addr_bx(3)->east = addr_bx(2);
					addr_bx(3)->north = addr_bx(0);
					addr_bx(3)->above = addr_bx(7);




					addr_bx(0 + 4)->east = addr_bx(1 + 4);
					addr_bx(0 + 4)->south = addr_bx(3 + 4);
					addr_bx(0 + 4)->below = addr_bx(4 - 4);

					addr_bx(1 + 4)->west = addr_bx(0 + 4);
					addr_bx(1 + 4)->south = addr_bx(2 + 4);
					addr_bx(1 + 4)->below = addr_bx(5 - 4);

					addr_bx(2 + 4)->west = addr_bx(3 + 4);
					addr_bx(2 + 4)->north = addr_bx(1 + 4);
					addr_bx(2 + 4)->below = addr_bx(6 - 4);


					addr_bx(3 + 4)->east = addr_bx(2 + 4);
					addr_bx(3 + 4)->north = addr_bx(0 + 4);
					addr_bx(3 + 4)->below = addr_bx(7 - 4);

					addr_bx(0)->cnumber = 0;
					addr_bx(1)->cnumber = 1;
					addr_bx(2)->cnumber = 2;
					addr_bx(3)->cnumber = 3;
					addr_bx(4)->cnumber = 4;
					addr_bx(5)->cnumber = 5;
					addr_bx(6)->cnumber = 6;
					addr_bx(7)->cnumber = 7;

					sector_p->c0 = addr_bx(0);
					sector_p->c1 = addr_bx(1);
					sector_p->c2 = addr_bx(2);
					sector_p->c3 = addr_bx(3);
					sector_p->c4 = addr_bx(4);
					sector_p->c5 = addr_bx(5);
					sector_p->c6 = addr_bx(6);
					sector_p->c7 = addr_bx(7);

				}
				else {
						std::vector<v3f_t> corners = sector.octant_points(1.0);
						std::vector<float> sdfs = global_evaluator->eval_sdf_at_points(corners);
						v3f_t edgePoints[12] = { v3f_null() };
				

						for (int i = 0; i < 4; i++) {
							int j1 = i;
							int j2 = (i + 1) % 4;

							edgePoints[i] = wsum(
								corners[j1],
								corners[j2],
								sdfs[j1],
								sdfs[j2]
								);


							edgePoints[i+4] = wsum(
								corners[j1+4],
								corners[j2+4],
								sdfs[j1+4],
								sdfs[j2+4]
							);

							edgePoints[i+8] = wsum(
								corners[j1],
								corners[j1+4],
								sdfs[j1],
								sdfs[j1+4]
							);

						}

						int lookup = 0;
						for (int ic = 0; ic < 8; ic++) {
							if (sdfs[ic] < ISOLEVEL) {
								lookup |= (1 << ic);
							}
						}

						int* cube_class = triTable[lookup];
						int nTriangles = tcount(cube_class);

						for (int it = 0; it < nTriangles; it++) {
							int iA = *(cube_class + it * 3 + 0);
							int iB = *(cube_class + it * 3 + 1);
							int iC = *(cube_class + it * 3 + 2);
							v3f_t Af = edgePoints[iA];
							v3f_t Bf = edgePoints[iB];
							v3f_t Cf = edgePoints[iC];
							triangles.push_back(Triangle3f(Af, Bf, Cf));
						}

						sector_p->lookup = lookup;

						if (lookup != 0) {
							if (sector.level > currentlevel) {
								DebugPrint("%d\n", sector.level);
								currentlevel = sector.level;
							}
						}

				}
				
			
		

			


		}

		




		//for (int is = 0; is < sectors.size(); is++) {
		//	box_t* box = &sectors[is];
		//	DebugPrint("\n");
		//	DebugPrint("Lookup %p: ",&sectors[is]);
		//	for (std::pair<int, int> lk : getLookups(box)) {
		//		if(lk.second!=0)
		//		DebugPrint("c%d %02X | ", lk.first, lk.second);
		//	}
		//	DebugPrint("\n");

		//}



		std::vector<std::pair<box_t*, box_t*>> patch_faces;



		for( int ib = 0; ib < sectors.size();ib++) {
			box_t* node = &sectors[ib];
			if (node->level < min_level) continue;




				


			
		
				std::vector<box_t*> adjacent;



				{
				



					if (node->cnumber == 0) {
						if (node->above) adjacent.push_back(node->above);
						if (node->east) adjacent.push_back(node->east);
						if (node->south) adjacent.push_back(node->south);

						if (node->prnt && node->prnt->below && node->prnt->below->c4) {
							adjacent.push_back(node->prnt->below->c4);
						}
						if (node->prnt && node->prnt->west && node->prnt->west->c1) {
							adjacent.push_back(node->prnt->west->c1);
						}
						if (node->prnt && node->prnt->north && node->prnt->north->c3) {
							adjacent.push_back(node->prnt->north->c3);
						}
					}






					if (node->cnumber == 1) {
						if (node->above) adjacent.push_back(node->above);
						if (node->west) adjacent.push_back(node->west);
						if (node->south) adjacent.push_back(node->south);

						if (node->prnt && node->prnt->below && node->prnt->below->c5) {
							adjacent.push_back(node->prnt->below->c5);
						}
						if (node->prnt && node->prnt->east && node->prnt->east->c0) {
							adjacent.push_back(node->prnt->east->c0);
						}
						if (node->prnt && node->prnt->north && node->prnt->north->c2) {
							adjacent.push_back(node->prnt->north->c2);
						}
					}






					if (node->cnumber == 2) {
						if (node->above) adjacent.push_back(node->above);
						if (node->west) adjacent.push_back(node->west);
						if (node->north) adjacent.push_back(node->north);

						if (node->prnt && node->prnt->below && node->prnt->below->c6) {
							adjacent.push_back(node->prnt->below->c6);
						}
						if (node->prnt && node->prnt->east && node->prnt->east->c3) {
							adjacent.push_back(node->prnt->east->c3);
						}
						if (node->prnt && node->prnt->south && node->prnt->south->c1) {
							adjacent.push_back(node->prnt->south->c1);
						}
					}






					if (node->cnumber == 3) {
						if (node->above) adjacent.push_back(node->above);
						if (node->east) adjacent.push_back(node->east);
						if (node->north) adjacent.push_back(node->north);

						if (node->prnt && node->prnt->below && node->prnt->below->c7) {
							adjacent.push_back(node->prnt->below->c7);
						}
						if (node->prnt && node->prnt->west && node->prnt->west->c2) {
							adjacent.push_back(node->prnt->west->c2);
						}
						if (node->prnt && node->prnt->south && node->prnt->south->c0) {
							adjacent.push_back(node->prnt->south->c0);
						}
					}






					if (node->cnumber == 4) {
						if (node->below) adjacent.push_back(node->below);
						if (node->east) adjacent.push_back(node->east);
						if (node->south) adjacent.push_back(node->south);

						if (node->prnt && node->prnt->above && node->prnt->above->c0) {
							adjacent.push_back(node->prnt->above->c0);
						}
						if (node->prnt && node->prnt->west && node->prnt->west->c5) {
							adjacent.push_back(node->prnt->west->c5);
						}
						if (node->prnt && node->prnt->north && node->prnt->north->c7) {
							adjacent.push_back(node->prnt->north->c7);
						}
					}






					if (node->cnumber == 5) {
						if (node->below) adjacent.push_back(node->below);
						if (node->west) adjacent.push_back(node->west);
						if (node->south) adjacent.push_back(node->south);

						if (node->prnt && node->prnt->above && node->prnt->above->c1) {
							adjacent.push_back(node->prnt->above->c1);
						}
						if (node->prnt && node->prnt->east && node->prnt->east->c4) {
							adjacent.push_back(node->prnt->east->c4);
						}
						if (node->prnt && node->prnt->north && node->prnt->north->c6) {
							adjacent.push_back(node->prnt->north->c6);
						}
					}






					if (node->cnumber == 6) {
						if (node->below) adjacent.push_back(node->below);
						if (node->west) adjacent.push_back(node->west);
						if (node->north) adjacent.push_back(node->north);

						if (node->prnt && node->prnt->above && node->prnt->above->c2) {
							adjacent.push_back(node->prnt->above->c2);
						}
						if (node->prnt && node->prnt->east && node->prnt->east->c7) {
							adjacent.push_back(node->prnt->east->c7);
						}
						if (node->prnt && node->prnt->south && node->prnt->south->c5) {
							adjacent.push_back(node->prnt->south->c5);
						}
					}






					if (node->cnumber == 7) {
						if (node->below) adjacent.push_back(node->below);
						if (node->east) adjacent.push_back(node->east);
						if (node->north) adjacent.push_back(node->north);

						if (node->prnt && node->prnt->above && node->prnt->above->c3) {
							adjacent.push_back(node->prnt->above->c3);
						}
						if (node->prnt && node->prnt->west && node->prnt->west->c6) {
							adjacent.push_back(node->prnt->west->c6);
						}
						if (node->prnt && node->prnt->south && node->prnt->south->c4) {
							adjacent.push_back(node->prnt->south->c4);
						}
					}




				
				}


				if (node->lookup!=0)
					DebugPrint("node %p lvl %d adj %d\n", node - &sectors[0], node->level, adjacent.size());



				for (int ia = 0; ia < adjacent.size(); ia++) {
					
					if (node->lookup != 0) {
						DebugPrint("%d %d, %p %d\n",node->split,adjacent[ia]->split,adjacent[ia]-&sectors[0],adjacent[ia]->lookup);
						print_v3f(node->center);
						print_v3f(adjacent[ia]->center);

					}
					if (adjacent[ia]->split != node->split) patch_faces.push_back(std::make_pair(adjacent[ia],node));
				}

			

		
		}




		//for (int ip = 0; ip < patch_faces.size(); ip++) {
		//	if (patch_faces[ip].first < patch_faces[ip].second) {
		//		patch_faces[ip] = std::make_pair(patch_faces[ip].second,patch_faces[ip].first);
		//	}
		//}

		//std::sort(patch_faces.begin(), patch_faces.end());
		//patch_faces.erase(std::unique(patch_faces.begin(), patch_faces.end()), patch_faces.end());


		DebugPrint("num patch faces: %d\n", patch_faces.size());

		//for (int ip = 0; ip < patch_faces.size(); ip++) {
		//	DebugPrint("patch %p %p\n",patch_faces[ip].first, patch_faces[ip].second);
		//}

		for (int ip = 0; ip < patch_faces.size(); ip++) {
			std::pair<box_t *, box_t*> patch_face = patch_faces[ip];
			box_t * boxA = patch_face.first;
			box_t * boxB =patch_face.second;

			//if (boxIsEmpty(boxA) && boxIsEmpty(boxB)) continue;

			v3f_t dCenter = v3f_abs(v3f_sub(boxA->center,boxB->center));



#define swap_boxes(A,B) {box_t * temp = A; A = B; B= temp;}

			JunctionType junctionType = JunctionType::EastWest;

			if (dCenter.x > MCUBES_EPS) { junctionType = JunctionType::EastWest; };
			if (dCenter.y > MCUBES_EPS) { junctionType = JunctionType::AboveBelow; };
			if (dCenter.z > MCUBES_EPS) { junctionType = JunctionType::NorthSouth; };

			//for temp debugging

			//do the appropriate swaps
			switch (junctionType) {

			case JunctionType::EastWest:
					if (boxA->center.x > boxB->center.x) swap_boxes(boxA,boxB);
				break;

				case JunctionType::NorthSouth:
					//TODO: swap such that boxA is always to the south, whether it is whole or subdivided
					if (boxA->center.z > boxB->center.z) swap_boxes(boxA, boxB);
				break;

				case JunctionType::AboveBelow:
					//TODO: swap such that boxA is always below, whether it is whole or subdivided
					if (boxA->center.y > boxB->center.y) swap_boxes(boxA, boxB);
				break;
			
			}

				if (boxIsEmpty(boxA)||boxIsEmpty(boxB)) continue;


				std::vector<v3f_t> edgePoints;
				std::vector<std::pair<int, int>> edgesByIndex;
				DebugPrint("Patch Face %p %p Junction Type %s,lookup %02X %02X:\n", boxA, boxB, JunctionTypeName(junctionType),boxA->lookup,boxB->lookup);
				DebugPrint("Lookup A: ");
		
				for (std::pair<int,int> lk : getLookups(boxA)) {
					DebugPrint("c%d %02X | ", lk.first,lk.second);
				}
				DebugPrint("\n");
				DebugPrint("Lookup B: ");
				for (std::pair<int, int> lk : getLookups(boxB)) {
					DebugPrint("c%d %02X | ", lk.first, lk.second);
				}
				DebugPrint("\n");


				print_v3f(boxA->center);
				print_v3f(boxB->center);

				DebugPrint("___\n");
				loadEdgesOnFace(boxA, boxB, junctionType, edgePoints, edgesByIndex);
				
		/*		DebugPrint("___");
				for (int ip = 0; ip < edgePoints.size(); ip++) {
					print_v3f(edgePoints[ip]);
				}
				DebugPrint("___");
				                       */                       

				//if (edgesByIndex.size() == 0) continue;

				DirectedGraph G;
				for (int ie = 0; ie < edgesByIndex.size(); ie++) {
					G.insertDualEdge(edgesByIndex[ie].first, edgesByIndex[ie].second);
				}

				int numAdj = 0;
				for (int ie = 0; ie < G.getAdjacencyList().size(); ie++) {
					numAdj += G.getAdjacencyList().at(ie).size();
				}
				DebugPrint("Junction type: %s, Num Nodes: %d, NumAdj %d\n", JunctionTypeName(junctionType), G.getNodeCount(),numAdj);

				DebugPrint("num cycles %d\n", detectCycles(G.getAdjacencyList()).size())
				printCycles2(detectCycles(G.getAdjacencyList()));

				for (std::vector<int> _cycle : detectCycles(G.getAdjacencyList())) {
					std::deque<int> cycle;
					for (auto node : _cycle) cycle.push_back(node);
					if (cycle.size()>2) 
					{
						if (cycle.size() % 2 != 0) {
							patchTriangles.push_back(Triangle3f(
								edgePoints[cycle[0]], edgePoints[cycle[1]],
								edgePoints[cycle[cycle.size()-1]]
							));
							cycle.pop_front();
						}

						for (int node = 0; node < cycle.size() / 2-1; node++) {

							int antinode = cycle.size() - 1 - node;
							int a = node;
							int b = node + 1;
							int c = antinode - 1;
							int d = antinode;
							patchTriangles.push_back(Triangle3f(
								edgePoints[cycle[a]], edgePoints[cycle[b]], edgePoints[cycle[c]]
							));
							patchTriangles.push_back(Triangle3f(
								edgePoints[cycle[c]], edgePoints[cycle[d]], edgePoints[cycle[a]]
							));
						}
					}
				}

		




		}





		std::vector<Triangle3f> diagnostics;
		for (Triangle3f tr : triangles) {
			diagnostics.push_back(tr);
		}
		for (Triangle3f tr : patchTriangles) {
			diagnostics.push_back(tr);
		}

		Utils::write_stl("Untitled.stl", triangles);
		Utils::write_stl("patches.stl", patchTriangles);




		std::vector<v3f_t> Tpoints;
		for (int it = 0; it < diagnostics.size(); it++) {
			Tpoints.push_back(diagnostics.at(it).A);
			Tpoints.push_back(diagnostics.at(it).B);
			Tpoints.push_back(diagnostics.at(it).C);
		}


		
		for (int is = 0; is < 30; is++) {
			DebugPrint("Gradient Descent Step %d\n", is + 1);

			std::vector<v3f_t> gradients = global_evaluator->eval_normal_at_points(Tpoints);
			//print_v3f(gradients[gradients.size()/4-1]);
			std::vector<float> sdfs= global_evaluator->eval_sdf_at_points(Tpoints);
			for (int ip = 0; ip < Tpoints.size(); ip++) {
				Tpoints[ip] = v3f_add(Tpoints[ip], v3f_scale(gradients[ip], (ISOLEVEL-sdfs[ip])));
			}
		}

		for (int it = 0; it < diagnostics.size(); it++) {
			diagnostics[it] = Triangle3f(Tpoints[it*3+0], Tpoints[it * 3 + 1], Tpoints[it * 3 + 2]);
		}



		Utils::write_stl("diagnostics.stl", diagnostics);