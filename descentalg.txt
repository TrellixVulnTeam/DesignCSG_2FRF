	{
		

			std::vector<v3f_t> Tpoints;


			for (int it = 0; it < triangles.size(); it++) {
				Tpoints.push_back(triangles.at(it).A);
				Tpoints.push_back(triangles.at(it).B);
				Tpoints.push_back(triangles.at(it).C);
			}


			for (int is = 0; is < 100; is++) {
				DebugPrint("Gradient Descent Step %d\n", is + 1);



				int cursor = 0;

				while (cursor < Tpoints.size()) {

					int amt = RESOLUTION*RESOLUTION;
					if (cursor + amt > Tpoints.size()) amt = Tpoints.size() - cursor;
					std::vector<v3f_t> _Tpoints = std::vector<v3f_t>(Tpoints.begin()+cursor,Tpoints.begin()+cursor+amt);
					std::vector<v3f_t> gradients = global_evaluator->eval_normal_at_points(_Tpoints);
					//print_v3f(gradients[gradients.size()/4-1]);
					std::vector<float> sdfs = global_evaluator->eval_sdf_at_points(_Tpoints);
					for (int ip = 0; ip < _Tpoints.size(); ip++) {
						Tpoints[cursor+ip] = v3f_add(Tpoints[cursor+ip], v3f_scale(gradients[ip], (ISOLEVEL - sdfs[ip])));
				/*		if (Tpoints[cursor + ip].x < -3.0) {
							DebugPrint("%f\n",sdfs[ip]);
							print_v3f(gradients[ip]);
						}*/
					
					}
					cursor += amt;
				}

			


			}

			for (int it = 0; it < triangles.size(); it++) {
				triangles[it] = Triangle3f(Tpoints[it * 3 + 0], Tpoints[it * 3 + 1], Tpoints[it * 3 + 2]);
			}


		}
